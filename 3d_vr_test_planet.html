<!doctype html>
<html lang="tr">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Gerçekçi VR Uzay Simülasyonu - Jüpiter & Sistem</title>
  
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';
    import { VRButton } from 'https://unpkg.com/three@0.152.2/examples/jsm/webxr/VRButton.js';

    
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000000);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // enable WebXR
    document.body.appendChild(renderer.domElement);
    document.body.appendChild(VRButton.createButton(renderer));

    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1e7);
    camera.position.set(0, 200, 600);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0,0,0);
    controls.update();

    
    const sunLight = new THREE.PointLight(0xffffff, 2.6, 0, 2);
    sunLight.position.set(-1000, 0, 0);
    scene.add(sunLight);

    
    const loader = new THREE.TextureLoader();

    
    const starsTex = loader.load('https://threejs.org/examples/textures/cube/Bridge2/posx.jpg', ()=>{});
    
    (function createPoints(){
      const geom = new THREE.BufferGeometry();
      const count = 12000;
      const positions = new Float32Array(count * 3);
      for(let i=0;i<count;i++){
        const r = Math.random()*8000 + 2000;
        const theta = Math.random()*Math.PI*2;
        const phi = Math.acos((Math.random()*2)-1);
        positions[i*3] = r*Math.sin(phi)*Math.cos(theta);
        positions[i*3+1] = r*Math.sin(phi)*Math.sin(theta);
        positions[i*3+2] = r*Math.cos(phi);
      }
      geom.setAttribute('position', new THREE.BufferAttribute(positions,3));
      const mat = new THREE.PointsMaterial({ size: 2, sizeAttenuation: true, opacity:0.9, transparent:true });
      const points = new THREE.Points(geom, mat);
      scene.add(points);
    })();

    
   
    const SCALE_DIST = 0.0005; 
    const SCALE_MASS = 1e-6;    
    const TIME_STEP = 60*60*24; 
    let timeMultiplier = 1;     

    
    const bodiesData = [
      {name:'Sun', radius:696340, dist:0, mass:1989000, texture:'https://threejs.org/examples/textures/planets/sun.jpg'},
      {name:'Mercury', radius:2439.7, dist:57910000, mass:0.330, texture:'https://threejs.org/examples/textures/planets/mercury.jpg'},
      {name:'Venus', radius:6051.8, dist:108200000, mass:4.87, texture:'https://threejs.org/examples/textures/planets/venus.jpg'},
      {name:'Earth', radius:6371, dist:149600000, mass:5.97, texture:'https://threejs.org/examples/textures/planets/earth_atmos_2048.jpg'},
      {name:'Mars', radius:3389.5, dist:227900000, mass:0.642, texture:'https://threejs.org/examples/textures/planets/mars_1k_color.jpg'},
      {name:'Jupiter', radius:69911, dist:778500000, mass:1898, texture:'https://threejs.org/examples/textures/planets/jupiter.jpg'},
      {name:'Saturn', radius:58232, dist:1433000000, mass:568, texture:'https://threejs.org/examples/textures/planets/saturn.jpg'},
      {name:'Uranus', radius:25362, dist:2871000000, mass:86.8, texture:'https://threejs.org/examples/textures/planets/uranus.jpg'},
      {name:'Neptune', radius:24622, dist:4495000000, mass:102, texture:'https://threejs.org/examples/textures/planets/neptune.jpg'}
    ];

    
    const bodies = [];
    const G = 6.67430e-11; 

    
    for(const d of bodiesData){
      const body = {};
      body.name = d.name;
      body.mass = d.mass * 1e24 * SCALE_MASS;
      body.radius = Math.max(1, d.radius * SCALE_DIST); 
      
      const dist_m = d.dist * 1000; 
      body.position = new THREE.Vector3((dist_m * SCALE_DIST) || 0, 0, 0);
      
      if(d.name==='Sun') body.velocity = new THREE.Vector3(0,0,0);
      else{
        const r = dist_m;
        const M = bodiesData[0].mass * 1e24; 
        const v = Math.sqrt(G * M / r); 
        
        
        body.velocity = new THREE.Vector3(0, 0, v * SCALE_DIST);
      }
      
      const geom = new THREE.SphereGeometry(body.radius, 64, 64);
      const mat = new THREE.MeshStandardMaterial({map: loader.load(d.texture)});
      const mesh = new THREE.Mesh(geom, mat);
      mesh.name = d.name;
      mesh.position.copy(body.position);
      scene.add(mesh);
      body.mesh = mesh;

      bodies.push(body);
    }

    
    (function addRings(){
      const sat = bodies.find(b=>b.name==='Saturn');
      if(!sat) return;
      const inner = sat.radius*1.2;
      const outer = sat.radius*2.8;
      const ringGeo = new THREE.RingGeometry(inner, outer, 64);
      const ringMat = new THREE.MeshBasicMaterial({color:0xaaaa88, side:THREE.DoubleSide, transparent:true, opacity:0.7});
      const ring = new THREE.Mesh(ringGeo, ringMat);
      ring.rotation.x = Math.PI/2;
      sat.mesh.add(ring);
    })();

    
    function computeAccelerations(){
      
      const accs = bodies.map(_=>new THREE.Vector3(0,0,0));
      for(let i=0;i<bodies.length;i++){
        for(let j=i+1;j<bodies.length;j++){
          const bi = bodies[i];
          const bj = bodies[j];
          
          const rij = new THREE.Vector3().subVectors(bj.position, bi.position);
          const dist = rij.length();
          if(dist===0) continue;
          

          
          
          const pos_i_m = bi.position.clone().divideScalar(SCALE_DIST);
          const pos_j_m = bj.position.clone().divideScalar(SCALE_DIST);
          const r_m = new THREE.Vector3().subVectors(pos_j_m, pos_i_m);
          const dist_m = r_m.length();
          if(dist_m===0) continue;
          
          const mi = bi.mass / SCALE_MASS;
          const mj = bj.mass / SCALE_MASS;
          const force_mag = G * mi * mj / (dist_m*dist_m);
          const acc_i = r_m.clone().multiplyScalar(force_mag / mi / dist_m); 
          const acc_j = acc_i.clone().multiplyScalar(-1);
          
          accs[i].add(acc_i.multiplyScalar(SCALE_DIST));
          accs[j].add(acc_j.multiplyScalar(SCALE_DIST));
        }
      }
      return accs;
    }

    
    let lastTime = performance.now();
    let accumulator = 0;

    function simulate(deltaMs){
      
      const deltaSec = deltaMs / 1000;
      
      const physicsDt = TIME_STEP * timeMultiplier; 

      
      const accs = computeAccelerations();
      for(let i=0;i<bodies.length;i++){
        const b = bodies[i];
        
        const a = accs[i];
        b.velocity.add(a.clone().multiplyScalar(physicsDt));
        
        b.position.add(b.velocity.clone().multiplyScalar(physicsDt));
        
        b.mesh.position.copy(b.position);
      }
    }

   
    const infoDiv = document.createElement('div');
    infoDiv.style.position='fixed'; infoDiv.style.right='10px'; infoDiv.style.top='10px';
    infoDiv.style.padding='10px'; infoDiv.style.background='rgba(0,0,0,0.5)'; infoDiv.style.color='#fff';
    infoDiv.style.fontFamily='Arial'; infoDiv.innerHTML = '<b>Gerçekçi Simülasyon</b><br>Zaman Hızı: <span id="timeSpeed">1</span> gün/frame';
    document.body.appendChild(infoDiv);

    
    window.addEventListener('keydown', (e)=>{
      if(e.key === '+' || e.key === '='){ timeMultiplier *= 2; document.getElementById('timeSpeed')?.innerText = timeMultiplier; }
      if(e.key === '-' || e.key === '_'){ timeMultiplier = Math.max(0.125, timeMultiplier/2); document.getElementById('timeSpeed')?.innerText = timeMultiplier; }
    });

    
    function animate(){
      renderer.setAnimationLoop(()=>{
        const now = performance.now();
        const dt = now - lastTime; lastTime = now;
        simulate(dt);
        
        bodies.forEach(b=>{ if(b.mesh) b.mesh.rotation.y += 0.001; });
        renderer.render(scene, camera);
      });
    }
    animate();

    
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    
    window.addEventListener('click', (ev)=>{
      
      const mouse = new THREE.Vector2((ev.clientX / window.innerWidth) * 2 - 1, -(ev.clientY / window.innerHeight) * 2 + 1);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(scene.children, true);
      for(const it of intersects){
        const obj = it.object;
        if(obj.name){
          controls.target.copy(obj.getWorldPosition(new THREE.Vector3()));
          controls.update();
          break;
        }
      }
    });

    
    window.SIM = { bodies, setTimeMultiplier: (v)=>{timeMultiplier=v; document.getElementById('timeSpeed').innerText = v;} };

  </script>

  <style>
    html,body{height:100%;margin:0;background:#000;color:#ddd;font-family:Arial}
    #infoBox{position:fixed;left:10px;top:10px;padding:12px;background:rgba(0,0,0,0.45);border-radius:8px;z-index:10}
    button{margin:6px}
  </style>

  <div id="infoBox">
    <strong>VR Simülasyon</strong><br>
    - Çalıştırmak için terminalde: <code>python -m http.server 8000</code><br>
    - Tarayıcı: Chrome/Edge WebXR destekli.<br>
    - '+' veya '-' tuşlarıyla simülasyon hızını değiştirin.<br>
    - Tıklayıp gezegene odaklanabilirsiniz. VR modda el kontrolcülerle bakış kullanabilirsiniz.
  </div>
</body>
</html>
